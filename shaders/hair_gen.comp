#version 460

// Each group is one control hair, each invocation is one segment of that hair (N - 2 segments)
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Control hairs input buffer
layout(std430, binding = 0) readonly buffer ControlHairs {
    vec4 inV[];
};
// Bezier control points buffer
layout(std430, binding = 1) coherent buffer ControlPoints {
    vec4 controlBuf[];
};
// Smooth hairs output buffer - will contain control points during execution
layout(std430, binding = 2) coherent buffer InterpPoints {
    vec4 outV[];
};
// Hair index buffer (EBO)
layout(std430, binding = 3) writeonly buffer InterpIndices {
    uint indices[];
};
// Triangle elements
layout(std430, binding = 4) readonly buffer TriIndices {
    uint tris[];
};

// Number of control hairs
uniform uint H;
// Number of vertices in each control hair
uniform uint N;
// Number of output vertices per control hair vertex (minimum 2)
uniform uint M;
// Number of surface triangles
uniform uint T;
// Hair duplication / interpolation level across triangle face
uniform uint D;

/* 
Per hair (for H hairs):
    * N               : control hair vertices
    * 3N-2            : control points
    * M(N-1)+1        : output vertices
    * 2M(N-1)         : output indices
 */

// Compute index into output vertex buffer
//  h : hair index
//  i : segment index
//  j : subdiv vertex index
uint getOutVertIdx(uint h, uint i, uint j) {
    return h * (M*(N-1) + 1) + i*M + j;
}

// Compute index into output index buffer
//  h : hair index
//  i : segment index
//  j : subdiv vertex index
uint getOutElemIdx(uint h, uint i, uint j) {
    return 2 * (h * M*(N-1) + i*M + j);
}

// Compute index into bezier control points buffer
//  h : hair index
//  i : segment index
uint getCtrlPntIdx(uint h, uint i) {
    return h * (N*3 - 2) + 2 + i*3;
}

float xorshift32(uint x)
{
    for (int i = 0; i < 10; i++) {
        x ^= x << 13;
        x ^= x >> 17;
        x ^= x << 5;
    }
	return float(x) / float(0xFFFFFFFF);
}
highp float rand(uint i)
{
    vec2 co = vec2(xorshift32(i*37-1), xorshift32(i*33+1));
    highp float a = 12.9898;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}


void main() {
    // Thread (hair segment) index
    const uint i = gl_LocalInvocationID.x;
    if (i > N-1) {
        return;
    }

    // Hair index
    const uint h = gl_WorkGroupID.x;

    if (h < H) {

        // Offset into control points buffer
        uint ctlIdx = getCtrlPntIdx(h, i);
        // Offset into input vertices buffer
        uint vertOffset = h * N + i;

        // --- 1. Compute control points for this hair segment
        //        Each invocation gens 3 control points, except for first and last which gen 5
        const vec3 p[3] = {
            inV[vertOffset + 0].xyz,
            inV[vertOffset + 1].xyz,
            inV[vertOffset + 2].xyz
        };
        const vec3 tangent = normalize(p[2] - p[0]);

        // Add control points for segments until last two vertices
        ///TODO: No reason to store control points
        if (i <= N-3) {
            if (i == 0) {
                // First invocation, add 2 control points at start
                controlBuf[ctlIdx - 2] = vec4(p[0], 1.0);
                controlBuf[ctlIdx - 1] = vec4(p[0] + (p[1] - p[0]) * 0.1, 1.0);
            }
            
            // Add control points: one for each end of tangent, one for vertex
            controlBuf[ctlIdx + 0] = vec4(p[1] - tangent * length(p[1] - p[0]) * 0.5, 1.0);
            controlBuf[ctlIdx + 1] = vec4(p[1], 1.0);
            controlBuf[ctlIdx + 2] = vec4(p[1] + tangent * length(p[2] - p[1]) * 0.5, 1.0);
            
            if (i == N-3) {
                // Last invocation, add 2 control points at end
                controlBuf[ctlIdx + 3] = vec4(p[2] - (p[2] - p[1]) * 0.1, 1.0);
                controlBuf[ctlIdx + 4] = vec4(p[2], 1.0);
            }
        }

        // --- 2. Sync threads, then interpolate between control points to get smooth hair
        groupMemoryBarrier();
        const uint ctrlReadOffset = h * (N*3 - 2) + i*3;
        const vec3 ctrl[4] = {
            controlBuf[ctrlReadOffset + 0].xyz,
            controlBuf[ctrlReadOffset + 1].xyz,
            controlBuf[ctrlReadOffset + 2].xyz,
            controlBuf[ctrlReadOffset + 3].xyz
        };
        if (i <= N-2) {
            // Place M vertices along bezier curve
            for (uint j = 0; j < M; j++) {

                ///TODO: This can be optimized greatly by computing pows of t using int fractions j/(M-1)
                const float t = float(j) / float(M);
                float t2 = t * t;
                float t3 = t2 * t;
                float mt = 1.0 - t;
                float mt2 = mt * mt;
                float mt3 = mt2 * mt;
                const uint vIdx = getOutVertIdx(h, i, j);
                outV[vIdx] = vec4(
                    mt3 *           ctrl[0] +
                    3.0 * mt2 * t * ctrl[1] +
                    3.0 * mt * t2 * ctrl[2] +
                    t3 *            ctrl[3], 1.0);
                
                const uint eIdx = getOutElemIdx(h, i, j);
                indices[eIdx + 0] = vIdx;
                indices[eIdx + 1] = vIdx + 1;
            }
        } else if (i == N-1) {
            // Vertex at end of hair
            outV[getOutVertIdx(h, i, 0)] = vec4(p[0], 1.0);
        }
    }

    // --- 3. Sync, generate additional interpolated hairs
    memoryBarrierBuffer();
    for (uint j = 0; j < M; j++) {
        if (i >= N-1 && j > 0) {
            break;
        }
        const vec3 tri[3] = {
            outV[getOutVertIdx(tris[h*3 + 0], i, j)].xyz,
            outV[getOutVertIdx(tris[h*3 + 1], i, j)].xyz,
            outV[getOutVertIdx(tris[h*3 + 2], i, j)].xyz
        };
        for (uint n = 0; n < D; n++) {
            // Random barycentric coordinates
            float u = rand((h*D + n)*2 + 0);
            float v = 1.0 - u;
            float w = rand((h*D + n)*2 + 1);
            u -= w * 0.5;
            v -= w * 0.5;

            const uint vIdx = getOutVertIdx(H + h*D + n, i, j);
            outV[vIdx] = vec4(u*tri[0] + v*tri[1] + w*tri[2], 1.0);

            if (i < N-1) {
                const uint eIdx = getOutElemIdx(H + h*D + n, i, j);
                indices[eIdx + 0] = vIdx;
                indices[eIdx + 1] = vIdx + 1;
            }
        }
    }

}